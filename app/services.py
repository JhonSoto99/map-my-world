from datetime import datetime, timedelta
from typing import Type, TypeVar

from sqlmodel import Session, SQLModel, select

from app.exception_handlers import (
    CreateEntityError,
    CreateLocationCategoryReviewedError,
)
from app.models import LocationCategoryReviewed, LocationCategoryReviewedBase

T = TypeVar("T", bound=SQLModel)


def create_entity(
    session: Session, base_entity: SQLModel, model_class: Type[T]
):
    """
    Creates and saves an entity in the database.

    Converts a base entity to the specified model class,
    inserts it into the database,commits the transaction,
    and returns the created entity with a populated ID.

    Parameters:
    - session (Session): SQLAlchemy session for database operations.
    - base_entity (SQLModel): The base entity containing the initial data.
    - model_class (Type[T]): The SQLModel class representing the database table.

    Returns:
    - T: The created entity, including autogenerated fields (like ID).

    Raises:
    - Exception: Any error during database operations.
    """
    try:
        entity = model_class(**base_entity.dict())
        session.add(entity)
        session.commit()
        session.refresh(entity)

        return entity

    except Exception as e:
        session.rollback()
        raise CreateEntityError(f"Error: {e}") from e


def get_entity_or_404(
    entity_class: Type[SQLModel], entity_id: int, session: Session
):
    """
    Retrieves an entity by its ID or raises an error if not found.

    Parameters:
    - entity_class (Type[SQLModel]): The model class to query.
    - entity_id (int): The ID of the entity.
    - session (Session): Database session.

    Returns:
    - SQLModel: The found entity.

    Raises:
    - CreateLocationCategoryReviewedError: If the entity is not found.
    """
    entity = session.get(entity_class, entity_id)
    if not entity:
        raise CreateLocationCategoryReviewedError(
            f"{entity_class.__name__} with id {entity_id} not found."
        )
    return entity


def save_review_location_category(
    session: Session, location_category_reviewed: LocationCategoryReviewedBase
):
    """
    Saves or updates a review record for a specific location and category.

    - If a record exists for the provided `location_id` and `category_id`,
        updates the `last_reviewed` date.
    - If no record exists, creates a new one with the provided details.

    **Parameters:**
    - session (Session): Database session for executing queries.
    - location_category_reviewed (LocationCategoryReviewedBase): Data for location-category review.

    **Returns:**
    - LocationCategoryReviewed: The saved or updated review record.

    Raises:
    - Exception: Any error during database operations.
    """
    location_id: int = location_category_reviewed.location_id
    category_id: int = location_category_reviewed.category_id

    record = session.exec(
        select(LocationCategoryReviewed).where(
            LocationCategoryReviewed.location_id == location_id,
            LocationCategoryReviewed.category_id == category_id,
        )
    ).first()

    try:
        if not record:
            record = LocationCategoryReviewed(
                **location_category_reviewed.dict()
            )
            session.add(record)

        else:
            last_reviewed: datetime = location_category_reviewed.last_reviewed
            record.last_reviewed = (
                last_reviewed if last_reviewed else datetime.utcnow()
            )

        session.commit()
        session.refresh(record)
        return record
    except Exception as e:
        session.rollback()
        raise CreateEntityError(f"Error: {e}") from e


def get_unreviewed_recommendations(session: Session):
    """
    Retrieves the first 10 location-category reviews that are either not reviewed
    or have not been reviewed in the last 30 days.

    **Parameters:**
    - session (Session): The database session.

    **Returns:**
    - List[LocationCategoryReviewed]: A list of unreviewed location-category relationships.

    """
    thirty_days_ago = datetime.utcnow() - timedelta(days=30)
    statement = (
        select(LocationCategoryReviewed)
        .where(
            (LocationCategoryReviewed.last_reviewed == None)
            | (LocationCategoryReviewed.last_reviewed < thirty_days_ago)
        )
        .order_by(
            LocationCategoryReviewed.last_reviewed.is_(None).desc(),
            LocationCategoryReviewed.last_reviewed.asc(),
        )
        .limit(10)
    )
    results = session.exec(statement).all()
    return results
