from datetime import datetime, timedelta
from typing import Type, TypeVar

from sqlmodel import Session, SQLModel, select

from app.exception_handlers import (CreateEntityError,
                                    CreateLocationCategoryReviewedError)
from app.models import LocationCategoryReviewed, LocationCategoryReviewedBase

T = TypeVar("T", bound=SQLModel)


def create_entity(session: Session, base_entity: SQLModel, model_class: Type[T]):
    """
    Creates and saves an entity in the database.

    Converts a base entity to the specified model class,
    inserts it into the database,commits the transaction,
    and returns the created entity with a populated ID.

    Parameters:
    - session (Session): SQLAlchemy session for database operations.
    - base_entity (SQLModel): The base entity containing the initial data.
    - model_class (Type[T]): The SQLModel class representing the database table.

    Returns:
    - T: The created entity, including autogenerated fields (like ID).

    Raises:
    - Exception: Any error during database operations.
    """
    try:
        entity = model_class(**base_entity.dict())
        session.add(entity)
        session.commit()
        session.refresh(entity)

        return entity

    except Exception as e:
        session.rollback()
        raise CreateEntityError(f"Error: {e}") from e


def get_entity_or_404(entity_class: Type[SQLModel], entity_id: int, session: Session):
    """
    Retrieves an entity by its ID or raises an error if not found.

    Parameters:
    - entity_class (Type[SQLModel]): The model class to query.
    - entity_id (int): The ID of the entity.
    - session (Session): Database session.

    Returns:
    - SQLModel: The found entity.

    Raises:
    - CreateLocationCategoryReviewedError: If the entity is not found.
    """
    entity = session.get(entity_class, entity_id)
    if not entity:
        raise CreateLocationCategoryReviewedError(
            f"{entity_class.__name__} with id {entity_id} not found."
        )
    return entity


def save_review_location_category(
    session: Session, location_category_reviewed: LocationCategoryReviewedBase
):
    location_id: int = location_category_reviewed.location_id
    category_id: int = location_category_reviewed.category_id

    record = session.exec(
        select(LocationCategoryReviewed).where(
            LocationCategoryReviewed.location_id == location_id,
            LocationCategoryReviewed.category_id == category_id,
        )
    ).first()

    if not record:
        record = LocationCategoryReviewed(**location_category_reviewed.dict())
        session.add(record)

    else:
        last_reviewed: datetime = location_category_reviewed.last_reviewed
        record.last_reviewed = last_reviewed if last_reviewed else datetime.utcnow()

    session.commit()
    session.refresh(record)
    return record


def get_unreviewed_recommendations(session: Session):
    """
    Retrieves the first 10 location-category reviews that are either not reviewed
    or have not been reviewed in the last 30 days.

    **Parameters:**
    - session (Session): The database session.

    **Returns:**
    - List[LocationCategoryReviewed]: A list of unreviewed location-category relationships.

    """
    thirty_days_ago = datetime.utcnow() - timedelta(days=30)
    statement = (
        select(LocationCategoryReviewed)
        .where(
            (LocationCategoryReviewed.last_reviewed == None)
            | (LocationCategoryReviewed.last_reviewed < thirty_days_ago)
        )
        .order_by(
            LocationCategoryReviewed.last_reviewed.is_(None).desc(),
            LocationCategoryReviewed.last_reviewed.asc(),
        )
        .limit(10)
    )
    results = session.exec(statement).all()
    return results
